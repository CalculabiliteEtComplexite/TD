% SPDX-License-Identifier: CC-BY-SA-4.0
% Author: Matthieu Perrin
% Part: Reductions
% Section: Complexity
% Exercise: Bounded PCP

\begingroup

\begin{exercice}[Complexité de PCP borné]\label{exo:turingmachines/nondeterministic/pcp}

  On considère le problème \textsc{PCP borné} sur l'alphabet $\Sigma = \{a, b\}$, défini ci-dessous. 
  
  \Probleme{PCP borné}{
    Un couple $\langle D, N \rangle \in \mathscr{P}(\Sigma^+ \times \Sigma^+) \times \mathbb{N}$, où:
    \begin{itemize}
    \item $D = \left\{ \VDomino{\alpha_1}{\beta_1}, \VDomino{\alpha_2}{\beta_2}, \ldots, \VDomino{\alpha_m}{\beta_m}\right\}$
      est un ensemble fini de sortes de dominos ;
    \item $N$ est un entier, représentant une borne sur les ressources utilisables.
    \end{itemize}
  }{
    Existe-t-il un mot non vide de dominos
    $\VDomino{\alpha_{i_1}}{\beta_{i_1}} \cdots \VDomino{\alpha_{i_k}}{\beta_{i_k}} \in D^+$ tel que  :
    \begin{itemize}
    \item $\alpha_{i_1} \cdots \alpha_{i_k} = \beta_{i_1} \cdots \beta_{i_k}$ ;
    \item $k \le N$.
    \end{itemize}
  }

  \begin{question}
  \item Les deux instances suivantes de \textsc{PCP borné} sont-elles positives ? 
    $$
    \left\langle \left\{ \VDomino{ab}{aba}, \VDomino{ab}{bab},  \VDomino{abab}{b}  \right\}, 4 \right\rangle
    \quad\text{et}\quad
    \left\langle \left\{ \VDomino{ab}{aba}, \VDomino{ab}{bab},  \VDomino{abab}{b}  \right\}, 2 \right\rangle
    $$
  \end{question}
  \begin{correction}
    \begin{itemize}
    \item La première instance a une solution : $\VDomino{ab}{aba} \VDomino{ab}{bab} \VDomino{ab}{aba}  \VDomino{abab}{b}$
    \item La deuxième n'en a pas. On peut tester toutes les solutions à un ou deux dominos. 
      Pour un domino, il n'y a clairement pas de solution.
      Pour deux dominos, soit il y aura 4 symboles en haut et 6 en bas, soit 6 en haut et 4 en bas, soit 8 en haut et 2 en bas. 
    \end{itemize}
  \end{correction}

  Le but de cet exercice est de comparer les deux définitions de $\text{NP}$.
  Pour cela, nous allons montrer de deux manières différentes que $\textsc{PCP borné} \in \text{NP}$.

  Dans un premier temps, nous voulons montrer que \textsc{PCP borné} est reconnu par une machine de Turing non déterministe.
  On se place dans le modèle des machines de Turing non déterministes à plusieurs rubans, tel que vu en cours.
  
  On propose l'encodage de l'entrée suivante. Au début de l'exécution :
  \begin{itemize}
  \item $D = \left\{ \VDomino{\alpha_1}{\beta_1}, \VDomino{\alpha_2}{\beta_2}, \ldots, \VDomino{\alpha_m}{\beta_m}\right\}$ est écrit sur le ruban \textsc{d} sous la forme 
    $$
    \langle \alpha_1 \mid \beta_1 \rangle \langle \alpha_2 \mid \beta_2 \rangle \cdots \langle \alpha_m \mid \beta_m \rangle ;
    $$
  \item un ruban \textsc{n} contenant l'encodage unaire $1^N$ ;
  \end{itemize}
  où les symboles $\langle$, $\rangle$, $\mid$ et $1$ sont des symboles de ruban n'appartenant pas à l'alphabet $\Sigma$.

  Pour toute instance $\langle D, N \rangle$ de \textsc{PCP borné}, on note $\mathit{longueur}(\langle D, N \rangle)$
  la longueur de l'encodage de l'instance sur les rubans \textsc{d} et \textsc{n}. En particulier,
  on a toujours $\mathit{longueur}(\langle D, N \rangle) \ge |D| + N$, puisque $N$ est encodé en unaire.
  
  \ifcorrection{\newpage}
  \begin{question}
  \item Construire une machine de Turing non déterministe qui accepte \textsc{PCP borné}.
    Vous pouvez introduire des rubans de travail supplémentaires si nécessaire. 
  \end{question}
  \begin{correction}
    \begin{tikzpicture}[turingMachine, x=35mm, y=20mm, baseline=(0.base)]
      \state[initial above] (0) at (1,1) {$0$}; 
      \state                (1) at (0,1) {$1$}; 
      \state                (2) at (0,0) {$2$}; 
      \state                (3) at (2,1) {$3$}; 
      \state[accepting]     (4) at (3,1) {$4$}; 

      \path (0) edge[loop below] node              {\smAlign{\smTMtransR[\textsc{d}]{y}{y}\smTMtransL[\textsc{d}]{y}{y}}}                     (0);
      \path (0) edge             node              {\smGroup{\smTMtransL[\textsc{a}]{\blank}{\blank}\smTMtransL[\textsc{b}]{\blank}{\blank}}} (3);
      \path (3) edge[loop below] node              {\smGroup{\smTMtransL[\textsc{a}]{x}{x}\smTMtransL[\textsc{b}]{x}{x}}}                     (3);
      \path (3) edge             node              {\smGroup{\smTMtransR[\textsc{a}]{\blank}{\blank}\smTMtransR[\textsc{b}]{\blank}{\blank}}} (4);
      \path (0) edge             node[swap]        {\smGroup{\smTMtransR[\textsc{d}]{\langle}{\langle}\smTMtransR[\textsc{n}]{1}{1}}} (1);
      \path (1) edge[loop left]  node              {\smGroup{\smTMtransR[\textsc{d}]{x}{x}\smTMtransR[\textsc{a}]{\blank}{x}}}                (1);
      \path (1) edge             node[swap]        {\smTMtransR[\textsc{d}]{|}{|}}                                                            (2);
      \path (2) edge[loop left]  node              {\smGroup{\smTMtransR[\textsc{d}]{x}{x}\smTMtransR[\textsc{b}]{\blank}{x}}}                (2);
      \path (2) edge             node[sloped]      {\smTMtransL[\textsc{d}]{\rangle}{\rangle}}                                                (0);
    \end{tikzpicture}
    
    $\forall x \in \{a, b\}, \forall y \in \{a, b, \langle, \rangle, |\}$
  \end{correction}

  \begin{question}
  \item Donner un polynôme $P(n)$ tel que, pour toute instance positive $\langle D, N \rangle$,
    il existe une exécution acceptante de cette machine dont la durée est inférieure à $P(\mathit{longueur}(\langle D, N \rangle))$.
  \end{question}
  \begin{correction}
    Une exécution consiste en au plus $N$ itérations de la boucle $0 \rightarrow 1 \rightarrow 2 \rightarrow 0$, suivies de la conclusion
    $0 \rightarrow 3 \rightarrow 4$.
    \begin{itemize}
    \item Chaque itération de la boucle lit complètement un domino une et une seule fois, donc s'exécute en au plus $\mathit{longueur}(D)$ étapes.
    \item La boucle principale termine donc en au plus $N \times \mathit{longueur}(D)$ étapes. 
    \item La conclusion parcourt \textsc{a} et \textsc{b} dans létat $3$.
      \textsc{a} et \textsc{b} ont été écrit lors de la boucle principale.
      Le temps d'exécution dans l'état $3$ est donc borné par celui de la boucle, soit $N \times \mathit{longueur}(D)$ étapes.
      On rajoute deux étapes pour les transitions $0 \rightarrow 3$ et $3 \rightarrow 4$.
    \end{itemize}
    Finalement, l'algorithme s'exécute en au plus $2 \times N \times \mathit{longueur}(D) + 2 = \mathcal{O}(N \times \mathit{longueur}(D))$ étapes. 
  \end{correction}
  
  On en déduit qu'il existe une machine de Turing non déterministe qui accepte \textsc{PCP borné} en temps polynomial,
  donc $\textsc{PCP borné} \in \text{NP}$.

  On veut maintenant montrer que $\textsc{PCP borné} \in \text{NP}$ en utilisant la caractérisation à base de \emph{certificats polynomiaux}.
  
  \begin{question}
  \item Quelle forme peut prendre un \emph{certificat} pour $\langle D, N \rangle \in \textsc{PCP borné}$ ?
    Justifier que votre certificat est bien polynomial en explicitant le polynome.
  \end{question}
  \begin{correction}
    Un certificat est une suite d'au plus $N$ dominos de $D$.
    \begin{itemize}
    \item Pour un algorithme, on la représente par un tableau de couples de chaînes de caractères.
    \item Pour une machine de Turing, on la représente par un mot
      $\langle \alpha_{i_1} \mid \beta_{i_1} \rangle \cdots \langle \alpha_{i_k} \mid \beta_{i_k} \rangle$
    \end{itemize}
    La longueur du certificat est bornée par $N \times \mathit{longueur}(\langle D, N \rangle)$.
  \end{correction}

  \ifcorrection{\newpage}
  \begin{question}
  \item Donner un algorithme qui vérifie qu'un candidat $C$
    est bien un certificat pour une instance $\langle D, N \rangle$ de \textsc{PCP borné}.
    Justifier que votre algorithme est bien polynomial en explicitant le polynome.
  \end{question}
  \begin{correction}
    \begin{algorithm}[H]
      \SetKwFunction{Verify}{verify}
      \SetKwFunction{Contains}{contains}
      \Fun{$\Verify(\langle D, N \rangle, c) $}{
        \tcp{vérification de $|c| \le n$ en $\mathcal{O}(1)$}
        \lIf{$|c| > N$}{
          \Return \False;
        }
        \tcp{vérification que tous les dominos de $c$ sont dans $D$ en $\mathcal{O}(|c|\times \mathit{longueur}(D))$}
        \For{$i$ \From $1$ \To $|c|$}{
          \lIf{$\lnot \Contains(D, c[i])$}{
            \Return \False;
          }
        }
        \tcp{Comparaison des chaînes concaténées en $\mathcal{O}(|c|^2)$ pas optimal, mais simple}
        $a \leftarrow \varepsilon$;
        $b \leftarrow \varepsilon$;\\
        \For{$i$ \From $1$ \To $|c|$}{
          $a \leftarrow a + c[i].\alpha$;
          $b \leftarrow b + c[i].\beta$;
        }
        \lIf{$a \neq b$}{
          \Return \False;
        }
      }
    \end{algorithm}

    L'algorithme est en $\mathcal{O}(|c|^2 + |c| \times \mathit{longueur}(D)) = \mathcal{O}(n^2)$, où $n$ est la longueur de l'entrée.
  \end{correction}

  
  On en déduit que \textsc{PCP borné} peut être vérifié en temps polynomial, donc $\textsc{PCP borné} \in \text{NP}$.

  \begin{question}
  \item Donner un algorithme déterministe qui décide \textsc{PCP borné}.
    Évaluer sa complexité temporelle en fonction de $|D|$ et $N$.
  \end{question}
  \begin{correction}
    \begin{algorithm}[H]
      \SetKwFunction{Verify}{verify}
      \SetKwFunction{Contains}{contains}
      \SetKwFunction{Decide}{decide}
      \SetKwFunction{Aux}{aux}
      \Fun{$\Decide(D, N) $}{
        \Return $\Aux(D, N, \varepsilon, \varepsilon)$
      }
      \Fun{$\Aux(D, N, a, b)$}{
        \lIf{$a=b \land a \neq \varepsilon$}{
          \Return \True;
        }
        \lIf{$N=0$}{
          \Return \False;
        }
        \For{$d \in D$}{
          \lIf{$\Aux(D, N, a + d.\alpha, b + d.\beta)$}{
            \Return \True;
          }
        }
        \Return \False;
      }
    \end{algorithm}
    L'algorithme est en $\mathcal{O}(|D|^N)$. La complexité est donc super-exponentielle en $\mathit{longueur}(\langle D, N\rangle)$. 
  \end{correction}
\end{exercice}

\endgroup
\endinput
